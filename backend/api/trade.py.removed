"""
Trade Execution API Endpoints
"""
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import func
from typing import List, Dict, Optional
from datetime import datetime
import logging

from backend.database import get_db
from backend.models import Order, Position, Instrument
from backend.schemas import Order as OrderSchema, Position as PositionSchema
from backend.services.trade_executor import TradeExecutor
from backend.services.order_sync import OrderSyncService
from backend.broker.kite.client import KiteBroker

router = APIRouter(prefix="/api/trade", tags=["trade"])
logger = logging.getLogger(__name__)

# Global trade executors
trade_executors: Dict[int, TradeExecutor] = {}


@router.post("/{strategy_id}/start")
async def start_trade_execution(strategy_id: int, db: Session = Depends(get_db)):
    """Start trade execution for a strategy"""
    try:
        # Check if already running
        if strategy_id in trade_executors:
            raise HTTPException(status_code=400, detail="Trade executor already running")
        
        # Get strategy
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # Get broker config
        from backend.models import BrokerConfig
        broker_config = db.query(BrokerConfig).filter(
            BrokerConfig.broker_type == strategy.broker_type,
            BrokerConfig.is_active == True
        ).first()
        
        if not broker_config:
            raise HTTPException(status_code=400, detail="No active broker configuration found")
        
        # Initialize broker
        broker = KiteBroker(
            api_key=broker_config.api_key,
            api_secret=broker_config.api_secret,
            access_token=broker_config.access_token
        )
        
        # Create and start executor
        executor = TradeExecutor(strategy_id, broker, db)
        trade_executors[strategy_id] = executor
        
        # Start in background
        import asyncio
        asyncio.create_task(executor.start())
        
        return {
            "success": True,
            "message": "Trade execution started",
            "strategy_id": strategy_id
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{strategy_id}/stop")
async def stop_trade_execution(strategy_id: int, db: Session = Depends(get_db)):
    """Stop trade execution for a strategy"""
    try:
        if strategy_id not in trade_executors:
            raise HTTPException(status_code=404, detail="Trade executor not running")
        
        executor = trade_executors[strategy_id]
        executor.stop()
        
        # Remove from dict
        del trade_executors[strategy_id]
        
        return {
            "success": True,
            "message": "Trade execution stopped",
            "strategy_id": strategy_id
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{strategy_id}/state")
async def get_trade_state(strategy_id: int, db: Session = Depends(get_db)):
    """Get current trade execution state"""
    try:
        # Get strategy from database
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # ALWAYS fetch from database (not just when executor is running)
        logger.info(f"[STATE] Fetching state for strategy {strategy_id}: {strategy.name}")
        
        # Get positions from database
        db_positions = db.query(Position).filter(
            Position.strategy_id == strategy_id,
            Position.closed_at.is_(None)
        ).all()
        
        logger.info(f"[STATE] Found {len(db_positions)} active positions in database")
        
        positions_data = [
            {
                "id": pos.id,
                "symbol": pos.symbol,
                "instrument_token": pos.instrument_token,
                "quantity": pos.quantity,
                "average_price": pos.average_price,
                "last_price": pos.last_price,
                "pnl": pos.pnl,
                "pnl_percentage": pos.pnl_percentage,
                "opened_at": pos.opened_at.isoformat(),
                "closed_at": pos.closed_at.isoformat() if pos.closed_at else None
            }
            for pos in db_positions
        ]
        
        # Calculate statistics from database
        statistics = _calculate_basic_statistics(db, strategy_id)
        
        # Fetch available funds from broker
        available_funds = 100000  # Default
        trading_mode = "Paper"  # Default
        try:
            from backend.models import BrokerConfig
            broker_config = db.query(BrokerConfig).filter(
                BrokerConfig.broker_type == strategy.broker_type,
                BrokerConfig.is_active == True
            ).first()
            
            if broker_config and broker_config.access_token:
                broker = KiteBroker(
                    api_key=broker_config.api_key,
                    api_secret=broker_config.api_secret,
                    access_token=broker_config.access_token
                )
                funds_data = broker.get_funds()
                equity_data = funds_data.get("equity", {})
                # Use available cash (includes intraday_payin)
                available_funds = equity_data.get("available", {}).get("cash", 100000)
                logger.info(f"[STATE] Fetched available cash: ₹{available_funds:,.2f}")
        except Exception as e:
            logger.warning(f"[STATE] Could not fetch funds from broker: {e}")
        
        # Get contract details from active positions
        contract_info = {
            "ce_symbol": None,
            "pe_symbol": None,
            "expiry": None,
            "days_to_expiry": None
        }
        
        if db_positions:
            # Get first position to extract contract info
            for pos in db_positions:
                try:
                    # Check if this is CE or PE from symbol
                    if 'CE' in pos.symbol and not contract_info["ce_symbol"]:
                        contract_info["ce_symbol"] = pos.symbol
                        # Get instrument details for expiry
                        instrument = db.query(Instrument).filter(
                            Instrument.tradingsymbol == pos.symbol
                        ).first()
                        if instrument and instrument.expiry:
                            contract_info["expiry"] = instrument.expiry
                            # Calculate days to expiry
                            from datetime import datetime
                            expiry_date = datetime.strptime(instrument.expiry, '%Y-%m-%d').date()
                            today = datetime.now().date()
                            days_diff = (expiry_date - today).days
                            contract_info["days_to_expiry"] = days_diff
                    elif 'PE' in pos.symbol and not contract_info["pe_symbol"]:
                        contract_info["pe_symbol"] = pos.symbol
                        if not contract_info["expiry"]:
                            # Get instrument details for expiry
                            instrument = db.query(Instrument).filter(
                                Instrument.tradingsymbol == pos.symbol
                            ).first()
                            if instrument and instrument.expiry:
                                contract_info["expiry"] = instrument.expiry
                                # Calculate days to expiry
                                from datetime import datetime
                                expiry_date = datetime.strptime(instrument.expiry, '%Y-%m-%d').date()
                                today = datetime.now().date()
                                days_diff = (expiry_date - today).days
                                contract_info["days_to_expiry"] = days_diff
                except Exception as e:
                    logger.warning(f"Error extracting contract info: {e}")
        
        # Count active positions and open orders
        active_positions_count = len(db_positions)
        open_orders_count = db.query(Order).filter(
            Order.strategy_id == strategy_id,
            Order.status.in_(['pending', 'open', 'trigger_pending'])
        ).count()
        
        # Get total P&L from closed positions
        total_pnl = db.query(func.sum(Position.pnl)).filter(
            Position.strategy_id == strategy_id,
            Position.closed_at.isnot(None)
        ).scalar() or 0.0
        
        # Build strategy conditions from database
        strategy_conditions = {
            "buy_conditions": [
                {
                    "type": "7ma",
                    "enabled": True,
                    "crossover_target": strategy.buy_price_percentage if strategy.buy_trigger_type == "7ma" else 1.5,
                    "sell_target": strategy.sell_target_percentage if strategy.buy_trigger_type == "7ma" else 2.5
                },
                {
                    "type": "20ma",
                    "enabled": True,
                    "crossover_target": strategy.buy_price_percentage if strategy.buy_trigger_type == "20ma" else 3.0,
                    "sell_target": strategy.sell_target_percentage if strategy.buy_trigger_type == "20ma" else 5.0
                },
                {
                    "type": "lbb",
                    "enabled": True,
                    "crossover_target": strategy.buy_price_percentage if strategy.buy_trigger_type == "lbb" else 2.0,
                    "sell_target": strategy.sell_target_percentage if strategy.buy_trigger_type == "lbb" else 5.0
                }
            ],
            "sell_conditions": {
                "7ma_target": strategy.sell_target_percentage if strategy.buy_trigger_type == "7ma" else 2.5,
                "20ma_target": strategy.sell_target_percentage if strategy.buy_trigger_type == "20ma" else 5.0,
                "lbb_target": strategy.sell_target_percentage if strategy.buy_trigger_type == "lbb" else 10.0
            },
            "contract_settings": {
                "lot_size": 75,
                "tick_size": 0.05,
                "strike_gap": strategy.strike_offset or 100,
                "option_type": strategy.option_type or "OTM"
            }
        }
        
        # Base state from database
        state = {
            "strategy_id": strategy_id,
            "strategy_name": strategy.name,
            "status": "stopped",
            "index_ltp": 0,
            "index_symbol": strategy.instrument_symbol or "NIFTY 50",
            "last_update": datetime.utcnow().isoformat(),
            "positions": positions_data,
            "indicators": {},
            "notifications": [],
            "statistics": statistics,
            "config": {
                "total_capital": available_funds,
                "available_funds": available_funds,
                "lot_size": 75,
                "tick_size": 0.05,
                "auto_square_off": True,
                "auto_square_off_time": "15:28",
                "paper_trading": True,
                "trading_mode": trading_mode
            },
            "contract_info": contract_info,
            "active_positions_count": active_positions_count,
            "open_orders_count": open_orders_count,
            "total_pnl": total_pnl,
            "strategy_conditions": strategy_conditions
        }
        
        # If executor is running, overlay runtime data
        if strategy_id in trade_executors:
            executor = trade_executors[strategy_id]
            executor_state = executor.get_state()
            
            # Merge executor data (overrides database data where applicable)
            state["status"] = executor_state.get("status", "active")
            state["index_ltp"] = executor_state.get("index_ltp", 0)
            state["indicators"] = executor_state.get("indicators", {})
            state["notifications"] = executor_state.get("notifications", [])
            
            # Merge executor config if available
            if "config" in executor_state:
                state["config"].update(executor_state["config"])
            
            logger.info(f"[STATE] Strategy {strategy_id} executor is running, merged runtime data")
        else:
            logger.info(f"[STATE] Strategy {strategy_id} executor is not running, using database data only")
        
        return state
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[STATE] Error getting trade state for strategy {strategy_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{strategy_id}/orders")
async def get_trade_orders(
    strategy_id: int,
    status: Optional[str] = None,
    limit: int = 20,
    db: Session = Depends(get_db)
):
    """Get orders for a strategy"""
    try:
        query = db.query(Order).filter(Order.strategy_id == strategy_id)
        
        if status:
            query = query.filter(Order.status == status)
        
        orders = query.order_by(Order.placed_at.desc()).limit(limit).all()
        
        return {
            "orders": [
                {
                    "id": order.id,
                    "broker_order_id": order.broker_order_id,
                    "symbol": order.symbol,
                    "order_type": order.order_type,
                    "transaction_type": order.transaction_type,
                    "quantity": order.quantity,
                    "price": order.price,
                    "average_price": order.average_price,
                    "status": order.status,
                    "placed_at": order.placed_at.isoformat(),
                    "filled_at": order.filled_at.isoformat() if order.filled_at else None
                }
                for order in orders
            ]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{strategy_id}/positions")
async def get_trade_positions(
    strategy_id: int,
    active_only: bool = True,
    db: Session = Depends(get_db)
):
    """Get positions for a strategy"""
    try:
        query = db.query(Position).filter(Position.strategy_id == strategy_id)
        
        if active_only:
            query = query.filter(Position.closed_at.is_(None))
        
        positions = query.order_by(Position.opened_at.desc()).all()
        
        return {
            "positions": [
                {
                    "id": pos.id,
                    "symbol": pos.symbol,
                    "instrument_token": pos.instrument_token,
                    "quantity": pos.quantity,
                    "average_price": pos.average_price,
                    "last_price": pos.last_price,
                    "pnl": pos.pnl,
                    "pnl_percentage": pos.pnl_percentage,
                    "opened_at": pos.opened_at.isoformat(),
                    "closed_at": pos.closed_at.isoformat() if pos.closed_at else None
                }
                for pos in positions
            ]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/{strategy_id}/config")
async def update_trade_config(
    strategy_id: int,
    config: Dict,
    db: Session = Depends(get_db)
):
    """Update trade execution configuration"""
    try:
        if strategy_id not in trade_executors:
            raise HTTPException(status_code=404, detail="Trade executor not running")
        
        executor = trade_executors[strategy_id]
        
        # Update configuration
        if 'total_capital' in config:
            executor.config.total_capital = config['total_capital']
        
        if 'call_allocation' in config:
            executor.config.call_allocation = config['call_allocation']
        
        if 'put_allocation' in config:
            executor.config.put_allocation = config['put_allocation']
        
        if 'buy_conditions' in config:
            executor.config.buy_conditions.update(config['buy_conditions'])
        
        if 'lot_size' in config:
            executor.config.lot_size = config['lot_size']
        
        if 'tick_size' in config:
            executor.config.tick_size = config['tick_size']
        
        if 'auto_square_off' in config:
            executor.config.auto_square_off = config['auto_square_off']
        
        if 'paper_trading' in config:
            executor.config.paper_trading = config['paper_trading']
        
        return {
            "success": True,
            "message": "Configuration updated",
            "config": {
                'total_capital': executor.config.total_capital,
                'call_allocation': executor.config.call_allocation,
                'put_allocation': executor.config.put_allocation,
                'buy_conditions': executor.config.buy_conditions,
                'lot_size': executor.config.lot_size,
                'tick_size': executor.config.tick_size,
                'auto_square_off': executor.config.auto_square_off,
                'paper_trading': executor.config.paper_trading
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{strategy_id}/square-off")
async def manual_square_off(strategy_id: int, db: Session = Depends(get_db)):
    """Manually square off all positions"""
    try:
        if strategy_id not in trade_executors:
            raise HTTPException(status_code=404, detail="Trade executor not running")
        
        executor = trade_executors[strategy_id]
        await executor._square_off_all_positions()
        
        return {
            "success": True,
            "message": "Square off initiated"
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{strategy_id}/statistics")
async def get_trade_statistics(strategy_id: int, db: Session = Depends(get_db)):
    """Get trading statistics from database orders"""
    try:
        # Get broker config
        from backend.models import BrokerConfig
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        broker_config = db.query(BrokerConfig).filter(
            BrokerConfig.broker_type == strategy.broker_type,
            BrokerConfig.is_active == True
        ).first()
        
        # Initialize broker
        broker = None
        if broker_config:
            broker = KiteBroker(
                api_key=broker_config.api_key,
                api_secret=broker_config.api_secret,
                access_token=broker_config.access_token
            )
        
        # Create sync service and calculate statistics
        sync_service = OrderSyncService(db, broker) if broker else None
        
        if sync_service:
            stats = sync_service.calculate_trade_statistics(strategy_id)
        else:
            # Fallback to basic calculation if no broker
            stats = _calculate_basic_statistics(db, strategy_id)
        
        return stats
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{strategy_id}/sync-orders")
async def sync_orders(strategy_id: int, db: Session = Depends(get_db)):
    """Sync orders from broker API to database"""
    try:
        logger.info(f"[SYNC] Starting order sync for strategy {strategy_id}")
        
        # Get broker config
        from backend.models import BrokerConfig
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        broker_config = db.query(BrokerConfig).filter(
            BrokerConfig.broker_type == strategy.broker_type,
            BrokerConfig.is_active == True
        ).first()
        
        if not broker_config:
            raise HTTPException(status_code=400, detail="No active broker configuration found")
        
        # Initialize broker
        broker = KiteBroker(
            api_key=broker_config.api_key,
            api_secret=broker_config.api_secret,
            access_token=broker_config.access_token
        )
        
        # Sync orders
        sync_service = OrderSyncService(db, broker)
        result = await sync_service.sync_orders_from_broker(strategy_id)
        
        logger.info(f"[SYNC] Order sync complete for strategy {strategy_id}: {result}")
        return result
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[SYNC] Error syncing orders for strategy {strategy_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{strategy_id}/sync-positions")
async def sync_positions(strategy_id: int, db: Session = Depends(get_db)):
    """Sync positions from broker API to database"""
    try:
        logger.info(f"[SYNC] Starting position sync for strategy {strategy_id}")
        
        # Get broker config
        from backend.models import BrokerConfig
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        broker_config = db.query(BrokerConfig).filter(
            BrokerConfig.broker_type == strategy.broker_type,
            BrokerConfig.is_active == True
        ).first()
        
        if not broker_config:
            raise HTTPException(status_code=400, detail="No active broker configuration found")
        
        # Initialize broker
        broker = KiteBroker(
            api_key=broker_config.api_key,
            api_secret=broker_config.api_secret,
            access_token=broker_config.access_token
        )
        
        # Sync positions
        import asyncio
        broker_positions = await asyncio.to_thread(broker.get_positions)
        
        synced_count = 0
        updated_count = 0
        
        for broker_pos in broker_positions:
            # Check if position exists
            existing_pos = db.query(Position).filter(
                Position.strategy_id == strategy_id,
                Position.instrument_token == str(broker_pos.get('instrument_token', ''))
            ).first()
            
            if existing_pos:
                # Update existing position
                existing_pos.quantity = broker_pos.get('quantity', 0)
                existing_pos.average_price = broker_pos.get('average_price', 0)
                existing_pos.last_price = broker_pos.get('last_price', 0)
                existing_pos.pnl = broker_pos.get('pnl', 0)
                existing_pos.pnl_percentage = broker_pos.get('pnl_percentage', 0)
                updated_count += 1
                logger.debug(f"[SYNC] Updated position: {existing_pos.symbol}")
            else:
                # Create new position
                new_pos = Position(
                    strategy_id=strategy_id,
                    instrument_token=str(broker_pos.get('instrument_token', '')),
                    symbol=broker_pos.get('tradingsymbol', ''),
                    quantity=broker_pos.get('quantity', 0),
                    average_price=broker_pos.get('average_price', 0),
                    last_price=broker_pos.get('last_price', 0),
                    pnl=broker_pos.get('pnl', 0),
                    pnl_percentage=broker_pos.get('pnl_percentage', 0)
                )
                db.add(new_pos)
                synced_count += 1
                logger.debug(f"[SYNC] Created new position: {new_pos.symbol}")
        
        db.commit()
        
        result = {
            "synced": synced_count,
            "updated": updated_count,
            "total_broker_positions": len(broker_positions)
        }
        
        logger.info(f"[SYNC] Position sync complete for strategy {strategy_id}: {result}")
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"[SYNC] Error syncing positions for strategy {strategy_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{strategy_id}/sync-all")
async def sync_all(strategy_id: int, db: Session = Depends(get_db)):
    """Sync both orders and positions from broker API"""
    try:
        logger.info(f"[SYNC-ALL] Starting full sync for strategy {strategy_id}")
        
        # Get broker config
        from backend.models import BrokerConfig
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        broker_config = db.query(BrokerConfig).filter(
            BrokerConfig.broker_type == strategy.broker_type,
            BrokerConfig.is_active == True
        ).first()
        
        if not broker_config:
            logger.warning(f"[SYNC-ALL] No active broker configuration found for strategy {strategy_id}")
            raise HTTPException(status_code=400, detail="No active broker configuration found")
        
        # Initialize broker
        broker = KiteBroker(
            api_key=broker_config.api_key,
            api_secret=broker_config.api_secret,
            access_token=broker_config.access_token
        )
        
        import asyncio
        
        # Sync orders
        logger.info(f"[SYNC-ALL] Syncing orders for strategy {strategy_id}")
        sync_service = OrderSyncService(db, broker)
        orders_result = await sync_service.sync_orders_from_broker(strategy_id)
        logger.info(f"[SYNC-ALL] Orders sync result: {orders_result}")
        
        # Sync positions
        logger.info(f"[SYNC-ALL] Syncing positions for strategy {strategy_id}")
        positions_data = await asyncio.to_thread(broker.get_positions)
        
        # Get net positions (actual holdings)
        broker_positions = positions_data.get('net', [])
        
        synced_count = 0
        updated_count = 0
        
        for broker_pos in broker_positions:
            # Check if position exists
            existing_pos = db.query(Position).filter(
                Position.strategy_id == strategy_id,
                Position.instrument_token == str(broker_pos.get('instrument_token', ''))
            ).first()
            
            quantity = broker_pos.get('quantity', 0)
            
            # Skip if quantity is 0 (closed position)
            if quantity == 0:
                if existing_pos and not existing_pos.closed_at:
                    # Mark as closed
                    from datetime import datetime
                    existing_pos.closed_at = datetime.utcnow()
                    updated_count += 1
                    logger.debug(f"[SYNC-ALL] Closed position: {existing_pos.symbol}")
                continue
            
            if existing_pos:
                # Update existing position
                existing_pos.quantity = quantity
                existing_pos.average_price = broker_pos.get('average_price', 0)
                existing_pos.last_price = broker_pos.get('last_price', 0)
                pnl = broker_pos.get('pnl', 0)
                existing_pos.pnl = pnl
                if existing_pos.average_price != 0:
                    existing_pos.pnl_percentage = (pnl / (existing_pos.average_price * abs(quantity))) * 100
                updated_count += 1
                logger.debug(f"[SYNC-ALL] Updated position: {existing_pos.symbol}")
            else:
                # Create new position
                pnl = broker_pos.get('pnl', 0)
                avg_price = broker_pos.get('average_price', 0)
                pnl_pct = (pnl / (avg_price * abs(quantity)) * 100) if avg_price != 0 else 0
                
                new_pos = Position(
                    strategy_id=strategy_id,
                    instrument_token=str(broker_pos.get('instrument_token', '')),
                    symbol=broker_pos.get('tradingsymbol', ''),
                    quantity=quantity,
                    average_price=avg_price,
                    last_price=broker_pos.get('last_price', 0),
                    pnl=pnl,
                    pnl_percentage=pnl_pct
                )
                db.add(new_pos)
                synced_count += 1
                logger.debug(f"[SYNC-ALL] Created new position: {new_pos.symbol}")
        
        db.commit()
        
        positions_result = {
            "synced": synced_count,
            "updated": updated_count,
            "total_broker_positions": len(broker_positions)
        }
        
        logger.info(f"[SYNC-ALL] Positions sync result: {positions_result}")
        logger.info(f"[SYNC-ALL] Full sync complete for strategy {strategy_id}")
        
        return {
            "orders": orders_result,
            "positions": positions_result
        }
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"[SYNC-ALL] Error syncing strategy {strategy_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


def _calculate_basic_statistics(db: Session, strategy_id: int) -> Dict:
    """Calculate statistics from database orders"""
    stats = {
        'call': {
            'buy': 0, 
            'sell': 0, 
            'buy_value': 0, 
            'sell_value': 0, 
            'total_value': 0, 
            'pnl': 0
        },
        'put': {
            'buy': 0, 
            'sell': 0, 
            'buy_value': 0, 
            'sell_value': 0, 
            'total_value': 0, 
            'pnl': 0
        },
        'total': {
            'trades': 0, 
            'value': 0, 
            'buy_value': 0, 
            'sell_value': 0, 
            'pnl': 0, 
            'roc': 0
        }
    }
    
    # Query completed orders (with correct status values)
    orders = db.query(Order).filter(
        Order.strategy_id == strategy_id,
        Order.status.in_(['completed', 'rejected', 'cancelled'])
    ).all()
    
    logger.info(f"[STATS] Strategy {strategy_id}: Calculating statistics from {len(orders)} orders")
    
    for order in orders:
        # Improved CE/PE detection
        symbol_upper = order.symbol.upper()
        option_type = None
        
        if 'CE' in symbol_upper or 'CALL' in symbol_upper:
            option_type = 'call'
        elif 'PE' in symbol_upper or 'PUT' in symbol_upper:
            option_type = 'put'
        else:
            logger.warning(f"[STATS] Could not determine option type for symbol: {order.symbol}")
            continue
        
        # Use average_price if filled, else price
        actual_price = order.average_price if order.average_price else order.price
        value = actual_price * order.quantity
        
        logger.debug(f"[STATS] Order {order.id}: {option_type} {order.order_type} - {order.quantity} @ {actual_price} = {value}")
        
        if order.order_type == 'buy':
            stats[option_type]['buy'] += 1
            stats[option_type]['buy_value'] += value
        elif order.order_type == 'sell':
            stats[option_type]['sell'] += 1
            stats[option_type]['sell_value'] += value
    
    # Calculate totals
    stats['call']['total_value'] = stats['call']['buy_value']
    stats['call']['pnl'] = stats['call']['sell_value'] - stats['call']['buy_value']
    
    stats['put']['total_value'] = stats['put']['buy_value']
    stats['put']['pnl'] = stats['put']['sell_value'] - stats['put']['buy_value']
    
    # Grand totals
    stats['total']['trades'] = (stats['call']['buy'] + stats['call']['sell'] + 
                                 stats['put']['buy'] + stats['put']['sell'])
    stats['total']['buy_value'] = stats['call']['buy_value'] + stats['put']['buy_value']
    stats['total']['sell_value'] = stats['call']['sell_value'] + stats['put']['sell_value']
    stats['total']['value'] = stats['total']['buy_value']
    stats['total']['pnl'] = stats['call']['pnl'] + stats['put']['pnl']
    
    if stats['total']['buy_value'] > 0:
        stats['total']['roc'] = (stats['total']['pnl'] / stats['total']['buy_value']) * 100
    
    logger.info(f"[STATS] Strategy {strategy_id}: {stats['total']['trades']} trades, P&L: {stats['total']['pnl']:.2f}, ROC: {stats['total']['roc']:.2f}%")
    
    return stats


@router.get("/{strategy_id}/order-matrix")
async def get_order_matrix(strategy_id: int, db: Session = Depends(get_db)):
    """Get order matrix showing status of each condition/type combination"""
    try:
        # Get strategy
        strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # Initialize matrix structure
        conditions = ['7ma', '20ma', 'lbb']
        option_types = ['CE', 'PE']
        matrix = {}
        
        for condition in conditions:
            matrix[condition] = {}
            for option_type in option_types:
                matrix[condition][option_type] = {
                    'status': 'inactive',  # inactive, waiting, active
                    'quantity': 0,
                    'buy_price': 0.0,
                    'pnl': 0.0,
                    'symbol': None,
                    'order_id': None
                }
        
        # If executor is running, get live status
        if strategy_id in trade_executors:
            executor = trade_executors[strategy_id]
            executor_state = executor.get_state()
            
            # Get trends and indicators
            trends = executor._analyze_trends()
            indicators = executor.indicators_cache.get(executor.config.minor_trend_timeframe, {})
            ltp = executor.index_ltp
            
            # Update matrix with executor positions
            for position_data in executor_state.get('positions', []):
                condition = position_data['condition']
                option_type = position_data['type']
                
                if position_data['status'] in ['bought', 'sell_pending']:
                    # Active position
                    matrix[condition][option_type] = {
                        'status': 'active',
                        'quantity': position_data['quantity'],
                        'buy_price': position_data['buy_price'],
                        'pnl': 0.0,  # Calculate from current price
                        'symbol': position_data['symbol'],
                        'order_id': None
                    }
                elif position_data['status'] == 'idle':
                    # Check if waiting
                    waiting_status = _check_waiting_status(
                        condition,
                        option_type,
                        trends,
                        indicators,
                        ltp
                    )
                    matrix[condition][option_type]['status'] = waiting_status
        else:
            # Get positions from database
            db_positions = db.query(Position).filter(
                Position.strategy_id == strategy_id,
                Position.closed_at.is_(None)
            ).all()
            
            for pos in db_positions:
                # Try to determine condition and type from position
                # This requires parsing the symbol or having metadata
                option_type = 'CE' if 'CE' in pos.symbol else 'PE'
                
                # For now, just mark as active without knowing exact condition
                # This is a limitation - we'd need to store buy_condition in Position model
                for condition in conditions:
                    if matrix[condition][option_type]['status'] == 'inactive':
                        matrix[condition][option_type] = {
                            'status': 'active',
                            'quantity': pos.quantity,
                            'buy_price': pos.average_price,
                            'pnl': pos.pnl,
                            'symbol': pos.symbol,
                            'order_id': None
                        }
                        break
        
        return {
            'strategy_id': strategy_id,
            'matrix': matrix,
            'last_update': datetime.utcnow().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting order matrix for strategy {strategy_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


def _check_waiting_status(
    condition: str,
    option_type: str,
    trends: Dict,
    indicators: Dict,
    ltp: float
) -> str:
    """Check if a condition/type combination is in waiting status"""
    if not indicators or ltp == 0:
        return 'inactive'
    
    major_trend = trends.get('major', 'neutral')
    minor_trend = trends.get('minor', 'neutral')
    
    ma7 = indicators.get('ma7', 0)
    ma20 = indicators.get('ma20', 0)
    lbb = indicators.get('lbb', 0)
    
    if ma7 == 0 or ma20 == 0:
        return 'inactive'
    
    # CE (Call) Waiting Logic - when both trends are up
    if option_type == 'CE':
        if major_trend == 'uptrend' and minor_trend == 'uptrend':
            # LTP above 7MA → waiting for 7MA, others inactive
            if ltp > ma7:
                return 'waiting' if condition == '7ma' else 'inactive'
            # LTP between 7MA and 20MA → waiting for 20MA, others inactive
            elif ltp <= ma7 and ltp > ma20:
                return 'waiting' if condition == '20ma' else 'inactive'
            # LTP below 20MA and above LBB → waiting for LBB, others inactive
            elif ltp <= ma20 and (lbb == 0 or ltp > lbb):
                return 'waiting' if condition == 'lbb' else 'inactive'
            # LTP below LBB → all inactive
            else:
                return 'inactive'
        else:
            # CE inactive when minor trend is not up
            return 'inactive'
    
    # PE (Put) Waiting Logic
    elif option_type == 'PE':
        # Major up, Minor down → PE can be waiting
        if major_trend == 'uptrend' and minor_trend == 'downtrend':
            # LTP above 7MA → waiting for 7MA, others inactive
            if ltp > ma7:
                return 'waiting' if condition == '7ma' else 'inactive'
            # LTP between 7MA and 20MA → waiting for 20MA, others inactive
            elif ltp <= ma7 and ltp > ma20:
                return 'waiting' if condition == '20ma' else 'inactive'
            # LTP below 20MA and above LBB → waiting for LBB, others inactive
            elif ltp <= ma20 and (lbb == 0 or ltp > lbb):
                return 'waiting' if condition == 'lbb' else 'inactive'
            else:
                return 'inactive'
        
        # Major down, Minor down → PE can be waiting
        elif major_trend == 'downtrend' and minor_trend == 'downtrend':
            # LTP above 7MA → waiting for 7MA, others inactive
            if ltp > ma7:
                return 'waiting' if condition == '7ma' else 'inactive'
            # LTP between 7MA and 20MA → waiting for 20MA, others inactive
            elif ltp <= ma7 and ltp > ma20:
                return 'waiting' if condition == '20ma' else 'inactive'
            # LTP below 20MA and above LBB → waiting for LBB, others inactive
            elif ltp <= ma20 and (lbb == 0 or ltp > lbb):
                return 'waiting' if condition == 'lbb' else 'inactive'
            else:
                return 'inactive'
        
        # Major down, Minor up → could also trigger PE waiting
        elif major_trend == 'downtrend' and minor_trend == 'uptrend':
            # LTP above 7MA → waiting for 7MA, others inactive
            if ltp > ma7:
                return 'waiting' if condition == '7ma' else 'inactive'
            # LTP between 7MA and 20MA → waiting for 20MA, others inactive
            elif ltp <= ma7 and ltp > ma20:
                return 'waiting' if condition == '20ma' else 'inactive'
            # LTP below 20MA and above LBB → waiting for LBB, others inactive
            elif ltp <= ma20 and (lbb == 0 or ltp > lbb):
                return 'waiting' if condition == 'lbb' else 'inactive'
            else:
                return 'inactive'
        else:
            return 'inactive'
    
    return 'inactive'
